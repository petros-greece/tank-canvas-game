<!DOCTYPE html>
<html lang="el">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tank Rotated 90 Degrees Right</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background-color: #e0e0e0;
    }

    canvas {
      background-color: #ffffff;
    }
  </style>
</head>

<body>
  <canvas id="tankCanvas" width="700" height="700"></canvas>


  <button id="shoot">shoot</button>

  <script>
    // Λήψη του canvas και του context
    const canvas = document.getElementById("tankCanvas");
    const ctx = canvas.getContext("2d");

    game = {
      //frame: 0
    }

    /////////////////////////////////////////////////////////

    function Tank(ctx, options = {}) {
      this.ctx = ctx;
      this.team = options.team || 1;
      // Set up position with default values
      this.position = this.position || {};
      this.position.x = options.position.x;  // Default x position
      this.position.y = options.position.y; // Default y position
      this.moveToPos = options.moveToPos || {};
      this.moveToPos.x = options.moveToPos.x;
      this.moveToPos.y = options.moveToPos.y;
      // Assign other tank properties with option values or defaults
      this.bodyFill = options.bodyFill ?? "rgba(100,100,100,1)";
      this.towerFill = options.towerFill ?? "rgba(50,50,50,1)";
      this.cannonFill = options.cannonFill ?? "#2b4b29";
      this.wheelTracksStroke = options.wheelTracksStroke ?? "rgb(0,0,0)";
      this.wheelTracksFill = options.wheelTracksFill ?? "rgba(50,50,50,1)";
      this.wheelTracksLineNum = options.wheelTracksLineNum ?? 6;
      this.selectionColor = options.selectionColor ?? "rgba(50,50,50,.3)";

      // Assign defaults for size, speed, angles, and other parameters
      this.size = options.size ?? 10;
      this.speed = options.speed ?? 1;
      this.range = options.range ?? this.size*10;
      this.angle = options.angle ?? 10;
      this.cannonAngle = options.cannonAngle ?? 10;
      this.frame = Math.floor(Math.random() * 10);
      this.selected = false;
      this.stopped = false;
      // Component object for calculations or stored dimensions
      this.comp = {};
    }

    Tank.prototype.init = function () {
      this.comp.fullSize = 14 * this.size;
      this.comp.halfSize = 7 * this.size;
      this.comp.selectionSize = 10 * this.size;
      this.comp.isLockedDir = false;
      this.comp.lineDist = (this.comp.fullSize) / this.wheelTracksLineNum;
    }

    Tank.prototype.render = function () {

      const size = this.size;
      const ctx = this.ctx;

      this.renderSelection(ctx);
      this.renderBody(ctx, size);
      this.renderTracks(ctx, size);
      this.renderCannon(ctx, size);

    }

    Tank.prototype.renderCannon = function (ctx, size) {
      ctx.save();
      //ctx.rotate(this.cannonAngle * (Math.PI / 180));
      ctx.fillStyle = this.cannonFill;
      ctx.fillRect(2 * this.size, -0.5 * this.size, 6 * this.size, this.size);
      ctx.restore();
    }

    Tank.prototype.renderTracks = function (ctx, size) {
      // Draw tracks
      ctx.fillStyle = this.wheelTracksFill;
      ctx.fillRect(-this.comp.halfSize, -5.5 * size, this.comp.fullSize, 2 * size); // Upper track
      ctx.fillRect(-this.comp.halfSize, 3.5 * size, this.comp.fullSize, 2 * size); // Lower track

      // Draw wheels lines
      ctx.beginPath();
      ctx.strokeStyle = this.wheelTracksStroke;
      const lineDist = this.comp.lineDist;
      const frame = this.frame % lineDist;

      for (let i = 0; i < this.wheelTracksLineNum; i++) {
        ctx.moveTo(-this.comp.halfSize + (i * lineDist + frame), -3.5 * size);
        ctx.lineTo(-this.comp.halfSize + (i * lineDist + frame), -5.5 * size);
        ctx.moveTo(-this.comp.halfSize + (i * lineDist + frame), 3.5 * size);
        ctx.lineTo(-this.comp.halfSize + (i * lineDist + frame), 5.5 * size);
      }
      ctx.stroke();
    }

    Tank.prototype.renderBody = function(ctx, size){
      // Draw tank body
      ctx.fillStyle = this.bodyFill;
      ctx.fillRect(-this.comp.halfSize, -3.5 * size, this.comp.fullSize, this.comp.halfSize);

      // Draw tank tower
      ctx.fillStyle = this.towerFill;
      ctx.beginPath();
      ctx.arc(0, 0, 2 * size, 0, Math.PI * 2);
      ctx.fill();
    }

    Tank.prototype.renderSelection = function(ctx){
      if(this.selected) {
        ctx.fillStyle = this.selectionColor;
        ctx.beginPath();
        ctx.arc(0, 0, this.comp.selectionSize, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    Tank.prototype.moveTo = function () {
      
      const dx = this.moveToPos.x - this.position.x;
      const dy = this.moveToPos.y - this.position.y;
      const targetAngle = Math.atan2(dy, dx) * (180 / Math.PI); // Target angle in degrees
      const distance = Math.sqrt(dx * dx + dy * dy);

      // Calculate shortest angle difference (clockwise or counterclockwise)
      let angleDifference = (targetAngle - this.angle + 360) % 360;
      if (angleDifference > 180) angleDifference -= 360; // Adjust to the shortest direction

      const rotationSpeed = 1; // Speed of rotation
      const angleTolerance = 1; // Angle tolerance to prevent oscillation

      // Rotate gradually toward the target angle if not aligned
      if (Math.abs(angleDifference) >= angleTolerance && distance > this.speed) {
        if (angleDifference > 0) {
          this.angle += Math.min(rotationSpeed, angleDifference); // Rotate clockwise
        } else {
          this.angle -= Math.min(rotationSpeed, -angleDifference); // Rotate counterclockwise
        }
        this.frame += 1;
      }

      // Move forward if aligned within tolerance of the target direction
      if (Math.abs(angleDifference) <= angleTolerance && distance > this.speed) {
        const moveSpeed = Math.min(this.speed, distance);
        this.position.x += Math.cos(this.angle * (Math.PI / 180)) * moveSpeed;
        this.position.y += Math.sin(this.angle * (Math.PI / 180)) * moveSpeed;
        this.frame += 1;
      }

      this.draw(); 
      
    };

    Tank.prototype.collide = function(otherTank) {
      const dx = this.position.x - otherTank.position.x;
      const dy = this.position.y - otherTank.position.y;
      const collisionAngle = Math.atan2(dy, dx);
  
      this.position.x += Math.cos( collisionAngle) * this.speed*2;
      this.position.y += Math.sin( collisionAngle) * this.speed*2; 

      otherTank.position.x -= Math.cos( collisionAngle) * this.speed*2;
      otherTank.position.y -= Math.sin( collisionAngle) * this.speed*2; 
      //this.moveTo.y  =  this.position.y
      this.draw(); 
     
    }

    Tank.prototype.draw = function(){
      // Draw tank with the updated position and angle
      const ctx = this.ctx;
      ctx.save();
      ctx.translate(this.position.x, this.position.y);
      ctx.rotate(this.angle * (Math.PI / 180));
      this.render();
      ctx.restore();
    }

    Tank.prototype.checkIfClicked = function (position) {
      const size = this.size;

      // Tank dimensions centered on its position
      const halfWidth = this.comp.fullSize;
      const halfHeight = 7 * size;

      // Step 1: Translate the click position to the tank's local coordinate system
      const dx = position.x - this.position.x;
      const dy = position.y - this.position.y;

      // Step 2: Rotate the click point in the opposite direction of the tank's rotation
      const angleRad = -this.angle * (Math.PI / 180); // Convert angle to radians
      const rotatedX = dx * Math.cos(angleRad) - dy * Math.sin(angleRad);
      const rotatedY = dx * Math.sin(angleRad) + dy * Math.cos(angleRad);

      // Step 3: Check if the rotated click coordinates fall within the tank's rectangular boundaries
      const isWithinBounds = (
        rotatedX >= -halfWidth &&
        rotatedX <= halfWidth &&
        rotatedY >= -halfHeight &&
        rotatedY <= halfHeight
      );

      return isWithinBounds; // Returns true if within bounds, false otherwise
    };

    Tank.prototype.checkCollision = function (otherTank) {
      const dx = this.position.x - otherTank.position.x;
      const dy = this.position.y - otherTank.position.y;
      const distance = Math.sqrt(dx * dx + dy * dy);

      // Collision threshold based on tank size
      const collisionDistance = this.comp.halfSize + otherTank.comp.halfSize; // Adjust as needed based on tank size
      return distance < Math.floor(collisionDistance);
    };


    /////////////////////////////////////////////////////////////////

    function Missile(ctx, options = {}) {
      // Set up position with default values
      this.ctx = ctx;
      this.position = this.position || {};
      this.position.x = options.position?.x ?? 50;  // Default x position
      this.position.y = options.position?.y ?? 130; // Default y position
      this.width = options.width ?? 10;
      this.height = options.height ?? 50;
      this.flameToggle = false;
    }
    Missile.prototype.render = function () {
      this.renderBody(this.ctx);
    }


    Missile.prototype.renderBody = function (ctx) {
            // Missile Body
            ctx.fillStyle = "#555"; // Gray color for the body
            ctx.fillRect(this.position.x, this.position.y, this.width, this.height); // Minimal rectangular body

            // Missile Nose
            ctx.beginPath();
            ctx.moveTo(this.position.x, this.position.y); // Top left of the body
            ctx.lineTo(this.position.x + this.width / 2, this.position.y - this.height / 3); // Tip of the nose
            ctx.lineTo(this.position.x + this.width, this.position.y); // Top right of the body
            ctx.fillStyle = "#E53935"; // Red color .or the nose
            ctx.fill();
            ctx.closePath();

            // Draw the fire behind the missile
            this.renderFlame(this.ctx, this.position.x + this.width / 2, this.position.y + this.height);
     }

     Missile.prototype.renderFlame = function (ctx, x, y) {
            // Alternate the flame size for a flickering effect
            flameSize = this.flameToggle ? 8 : 12;
            this.flameToggle = !this.flameToggle;

            // Flame color and shape
            ctx.beginPath();
            ctx.moveTo(x, y); // Bottom center of missile
            ctx.lineTo(x - flameSize / 2, y + flameSize); // Left point of flame
            ctx.lineTo(x + flameSize / 2, y + flameSize); // Right point of flame
            ctx.closePath();

            // Gradient for the flame color
            const gradient = ctx.createRadialGradient(x, y, 0, x, y + flameSize, flameSize);
            gradient.addColorStop(0, "#FFA726"); // Orange
            gradient.addColorStop(1, "#FF5722"); // Darker orange

            ctx.fillStyle = gradient;
            ctx.fill();
        }

    
    ///////////////////////////////////////////////////////////////
    
    let misille = new Missile(ctx);
   



    /////////////////////////////////////////////////////////////

    options = {

      position: { x: 325, y: 215 },
      moveToPos:  { x: 325, y: 215 },
      wheelLineNum: 2,
      size: 5,
      speed: 1,
      frame: 0,
      cannonAngle: 67,

    }

    let tanks = [];

    for (let i = 0; i < 2; i += 1) {
      //debugger;
      let opts = JSON.parse(JSON.stringify(options));
      opts.position.y += i*130;
      opts.moveToPos.y += i*130;
      opts.team = i+1;
      let tank = new Tank(ctx, opts);
      tank.init();
      tanks.push(tank);
    }

    myTeam = 1;
    selectedTankIndex = -1;

    setInterval(function () {
      console.time('Game Loop')
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      tanks.forEach((t, index) => {
        if(selectedTankIndex > -1 && selectedTankIndex !==index && t.checkCollision(tanks[selectedTankIndex]) ){
          //tanks[selectedTankIndex].collide();
          tanks[selectedTankIndex].moveToPos = tanks[selectedTankIndex].position;
          //t.collide(tanks[selectedTankIndex]);
          tanks[selectedTankIndex].collide(t);
          //t.moveToPos  = JSON.parse(JSON.stringify(t.position));
          t.moveToPos = t.position; 
        }
        
        t.moveTo();
      });
      misille.render();

      console.timeEnd('Game Loop')
    }, 10);

    

    canvas.addEventListener('click', (event) => {
      const rect = canvas.getBoundingClientRect();
      const position = {x: event.clientX - rect.left, y: event.clientY - rect.top}
      let isClicked = false;
      
      tanks.forEach((t, index) => {
        t.selected = false;
         if ( t.checkIfClicked(position) ) {    
          selectedTankIndex = index;
          isClicked = true;
        }
      });

      // Move the selected tank to the clicked point
      if(!isClicked){
        tanks[selectedTankIndex].moveToPos = position; 
      }
      tanks[selectedTankIndex].selected = true;
    
    
    });





  </script>
</body>

</html>