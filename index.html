<!DOCTYPE html>
<html lang="el">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tank Rotated 90 Degrees Right</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background-color: #e0e0e0;
    }

    canvas {
      background-color: #ffffff;
    }
  </style>
</head>

<body>
  <canvas id="tankCanvas" width="700" height="700"></canvas>


  <button id="shoot">shoot</button>

  <script>
    // Λήψη του canvas και του context
    const canvas = document.getElementById("tankCanvas");
    const ctx = canvas.getContext("2d");

    game = {
      misilles: []
      //frame: 0
    }

    /////////////////////////////////////////////////////////

    function Tank(ctx, options = {}) {
      this.ctx = ctx;
      this.team = options.team || 1;
      // Set up position with default values
      this.position = this.position || {};
      this.position.x = options.position.x;  // Default x position
      this.position.y = options.position.y; // Default y position
      this.moveToPos = options.moveToPos || {};
      this.moveToPos.x = options.moveToPos.x;
      this.moveToPos.y = options.moveToPos.y;
      // Assign other tank properties with option values or defaults
      this.bodyFill = options.bodyFill ?? "rgba(100,100,100,1)";
      this.towerFill = options.towerFill ?? "rgba(50,50,50,1)";
      this.cannonFill = options.cannonFill ?? "#2b4b29";
      this.wheelTracksStroke = options.wheelTracksStroke ?? "rgb(0,0,0)";
      this.wheelTracksFill = options.wheelTracksFill ?? "rgba(50,50,50,1)";
      this.wheelTracksLineNum = options.wheelTracksLineNum ?? 6;
      this.selectionColor = options.selectionColor ?? "rgba(50,50,50,.3)";

      // Assign defaults for size, speed, angles, and other parameters
      this.size = options.size ?? 10;
      this.speed = options.speed ?? 1;
      this.range = options.range ?? this.size * 10;
      this.angle = options.angle ?? 360;
      this.cannonAngle = options.cannonAngle ?? 10;
      this.frame = Math.floor(Math.random() * 10);
      this.selected = false;
      this.stopped = false;
      // Component object for calculations or stored dimensions
      this.comp = {};
      this.init();
    }

    Tank.prototype.init = function () {
      this.comp.fullSize = 14 * this.size;
      this.comp.halfSize = 7 * this.size;
      this.comp.selectionSize = 10 * this.size;
      this.comp.isLockedDir = false;
      this.comp.lineDist = (this.comp.fullSize) / this.wheelTracksLineNum;
    }

    Tank.prototype.render = function () {

      const size = this.size;
      const ctx = this.ctx;

      this.renderSelection(ctx);
      this.renderBody(ctx, size);
      this.renderTracks(ctx, size);
      this.renderCannon(ctx, size);

    }

    Tank.prototype.renderCannon = function (ctx, size) {
      ctx.save();
      //ctx.rotate(this.cannonAngle * (Math.PI / 180));
      ctx.fillStyle = this.cannonFill;
      ctx.fillRect(2 * this.size, -0.5 * this.size, 6 * this.size, this.size);
      ctx.restore();
    }

    Tank.prototype.renderTracks = function (ctx, size) {
      // Draw tracks
      ctx.fillStyle = this.wheelTracksFill;
      ctx.fillRect(-this.comp.halfSize, -5.5 * size, this.comp.fullSize, 2 * size); // Upper track
      ctx.fillRect(-this.comp.halfSize, 3.5 * size, this.comp.fullSize, 2 * size); // Lower track

      // Draw wheels lines
      ctx.beginPath();
      ctx.strokeStyle = this.wheelTracksStroke;
      const lineDist = this.comp.lineDist;
      const frame = this.frame % lineDist;

      for (let i = 0; i < this.wheelTracksLineNum; i++) {
        ctx.moveTo(-this.comp.halfSize + (i * lineDist + frame), -3.5 * size);
        ctx.lineTo(-this.comp.halfSize + (i * lineDist + frame), -5.5 * size);
        ctx.moveTo(-this.comp.halfSize + (i * lineDist + frame), 3.5 * size);
        ctx.lineTo(-this.comp.halfSize + (i * lineDist + frame), 5.5 * size);
      }
      ctx.stroke();
    }

    Tank.prototype.renderBody = function (ctx, size) {
      // Draw tank body
      ctx.fillStyle = this.bodyFill;
      ctx.fillRect(-this.comp.halfSize, -3.5 * size, this.comp.fullSize, this.comp.halfSize);

      // Draw tank tower
      ctx.fillStyle = this.towerFill;
      ctx.beginPath();
      ctx.arc(0, 0, 2 * size, 0, Math.PI * 2);
      ctx.fill();
    }

    Tank.prototype.renderSelection = function (ctx) {
      if (this.selected) {
        ctx.fillStyle = this.selectionColor;
        ctx.beginPath();
        ctx.arc(0, 0, this.comp.selectionSize, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    Tank.prototype.moveTo = function () {

      const dx = this.moveToPos.x - this.position.x;
      const dy = this.moveToPos.y - this.position.y;
      const targetAngle = Math.atan2(dy, dx) * (180 / Math.PI); // Target angle in degrees
      const distance = Math.sqrt(dx * dx + dy * dy);

      // Calculate shortest angle difference (clockwise or counterclockwise)
      let angleDifference = (targetAngle - this.angle + 360) % 360;
      if (angleDifference > 180) angleDifference -= 360; // Adjust to the shortest direction

      const rotationSpeed = 1; // Speed of rotation
      const angleTolerance = 1; // Angle tolerance to prevent oscillation

      // Rotate gradually toward the target angle if not aligned
      if (Math.abs(angleDifference) >= angleTolerance && distance > this.speed) {
        if (angleDifference > 0) {
          this.angle += Math.min(rotationSpeed, angleDifference); // Rotate clockwise
        } else {
          this.angle -= Math.min(rotationSpeed, -angleDifference); // Rotate counterclockwise
        }
        this.frame += 1;
      }

      // Move forward if aligned within tolerance of the target direction
      if (Math.abs(angleDifference) <= angleTolerance && distance > this.speed) {
        const moveSpeed = Math.min(this.speed, distance);
        this.position.x += Math.cos(this.angle * (Math.PI / 180)) * moveSpeed;
        this.position.y += Math.sin(this.angle * (Math.PI / 180)) * moveSpeed;
        this.frame += 1;
      }

      this.draw();

    };

    Tank.prototype.collide = function (otherTank) {
      const dx = this.position.x - otherTank.position.x;
      const dy = this.position.y - otherTank.position.y;
      const collisionAngle = Math.atan2(dy, dx);

      this.position.x += Math.cos(collisionAngle) * this.speed * 2;
      this.position.y += Math.sin(collisionAngle) * this.speed * 2;

      otherTank.position.x -= Math.cos(collisionAngle) * this.speed * 2;
      otherTank.position.y -= Math.sin(collisionAngle) * this.speed * 2;
      //this.moveTo.y  =  this.position.y
      this.draw();

    }

    Tank.prototype.draw = function () {
      // Draw tank with the updated position and angle
      const ctx = this.ctx;
      ctx.save();
      ctx.translate(this.position.x, this.position.y);
      ctx.rotate(this.angle * (Math.PI / 180));
      this.render();
      ctx.restore();
    }

    Tank.prototype.checkIfClicked = function (position) {
      const size = this.size;

      // Tank dimensions centered on its position
      const halfWidth = this.comp.fullSize;
      const halfHeight = 7 * size;

      // Step 1: Translate the click position to the tank's local coordinate system
      const dx = position.x - this.position.x;
      const dy = position.y - this.position.y;

      // Step 2: Rotate the click point in the opposite direction of the tank's rotation
      const angleRad = -this.angle * (Math.PI / 180); // Convert angle to radians
      const rotatedX = dx * Math.cos(angleRad) - dy * Math.sin(angleRad);
      const rotatedY = dx * Math.sin(angleRad) + dy * Math.cos(angleRad);

      // Step 3: Check if the rotated click coordinates fall within the tank's rectangular boundaries
      const isWithinBounds = (
        rotatedX >= -halfWidth &&
        rotatedX <= halfWidth &&
        rotatedY >= -halfHeight &&
        rotatedY <= halfHeight
      );

      return isWithinBounds; // Returns true if within bounds, false otherwise
    };

    Tank.prototype.checkCollision = function (otherTank) {
      const dx = this.position.x - otherTank.position.x;
      const dy = this.position.y - otherTank.position.y;
      const distance = Math.sqrt(dx * dx + dy * dy);

      // Collision threshold based on tank size
      const collisionDistance = this.comp.halfSize + otherTank.comp.halfSize; // Adjust as needed based on tank size
      return distance < Math.floor(collisionDistance);
    };

    Tank.prototype.fireMisille = function(ctx){
      let misille = new Missile(ctx, {
        position: {
          x: this.position.x, 
          y: this.position.y-(this.size*2)
        },
        angle: this.angle,
        width: this.size,
        height: this.size*4
      });
      game.misilles.push(misille);
    }


    /////////////////////////////////////////////////////////////////

    function Missile(ctx, options = {}) {
      // Set up position with default values
      this.ctx = ctx;
      this.angle = options.angle || 90;
      this.position = this.position || {};
      this.position.x = options.position?.x ?? 350;  // Default x position
      this.position.y = options.position?.y ?? 130;  // Default y position
      this.width = options.width ?? 4;
      this.height = options.height ?? 12;
      this.flameToggle = false;
      this.isExploding = false;  // Explosion state
      this.explosionRadius = 0;  // Radius of the explosion effect
      this.hasExploded = false;
      this.speed = 16;
      this.comp = {}
      this.init()
    }

    Missile.prototype.init = function(){
      this.comp.halfW = this.width/2;
      this.comp.halfH = this.height/2;
    }

    Missile.prototype.render = function () {
      if (!this.hasExploded) {
        this.move();
        if (this.isExploding) {
          this.renderExplosion();
        } else {
          this.renderBody(this.ctx);
        }
      }
    };

    Missile.prototype.renderBody = function (ctx) {
      ctx.save(); // Save the current state

      // Move the canvas origin to the missile's center
      ctx.translate(this.position.x + this.comp.halfW, this.position.y + this.comp.halfH);
      ctx.rotate( (this.angle+90) * (Math.PI / 180) ); // Rotate the canvas by the missile's angle

      // Draw the missile body
      ctx.fillStyle = "#555";
      ctx.fillRect(-this.comp.halfW, -this.comp.halfH, this.width, this.height); // Centered rectangle

      // Draw the missile nose
      ctx.beginPath();
      ctx.moveTo(-this.comp.halfW, -this.comp.halfH); // Top left of the body
      ctx.lineTo(0, -this.comp.halfH - this.height / 3); // Tip of the nose
      ctx.lineTo(this.comp.halfW, -this.comp.halfH); // Top right of the body
      ctx.fillStyle = "#E53935";
      ctx.fill();
      ctx.closePath();

      // Draw the flame behind the missile
      this.renderFlame(ctx, 0, this.comp.halfH); // Position flame based on the rotated origin

      ctx.restore(); // Restore the original state
    };
    
    Missile.prototype.renderFlame = function (ctx, x, y) {
      // Alternate the flame size for a flickering effect
      let flameSize = this.flameToggle ? this.width : this.width * 2;
      this.flameToggle = !this.flameToggle;

      // Flame color and shape
      ctx.beginPath();
      ctx.moveTo(x, y); // Bottom center of missile
      ctx.lineTo(x - flameSize / 2, y + flameSize); // Left point of flame
      ctx.lineTo(x + flameSize / 2, y + flameSize); // Right point of flame
      ctx.closePath();

      // Gradient for the flame color
      const gradient = ctx.createRadialGradient(x, y, 0, x, y + flameSize, flameSize);
      gradient.addColorStop(0, "#FFA726"); // Orange
      gradient.addColorStop(1, "#FF5722"); // Darker orange

      ctx.fillStyle = gradient;
      ctx.fill();
    };

    Missile.prototype.explode = function () {
      this.isExploding = true;  // Set the explosion state
      this.explosionRadius = 0; // Start the explosion radius at 0
    };

    Missile.prototype.renderExplosion = function () {
      const maxRadius = 30; // Maximum radius for the explosion effect
      const fadeOutRadius = 40; // Radius at which the explosion will start to fade

      // Increase the explosion radius
      this.explosionRadius += 2;

      // Draw explosion with a radial gradient to simulate fading
      const gradient = this.ctx.createRadialGradient(
        this.position.x + this.comp.halfW,
        this.position.y + this.comp.halfH,
        0,
        this.position.x + this.comp.halfW,
        this.position.y + this.comp.halfH,
        this.explosionRadius
      );

      gradient.addColorStop(0, "#FF6F00"); // Bright orange at the center
      gradient.addColorStop(0.5, "#FF8E53"); // Lighter orange
      gradient.addColorStop(1, "rgba(255, 87, 34, 0)"); // Transparent at the edge

      this.ctx.fillStyle = gradient;
      this.ctx.beginPath();
      this.ctx.arc(
        this.position.x + this.comp.halfW,
        this.position.y + this.comp.halfH,
        this.explosionRadius,
        0,
        Math.PI * 2
      );
      this.ctx.fill();

      // End explosion effect after reaching the fade-out radius
      if (this.explosionRadius > fadeOutRadius) {
        this.isExploding = false; // Reset explosion state
        this.explosionRadius = 0;  // Reset radius
      }
    };

    Missile.prototype.move = function(){
      this.position.x += Math.cos(this.angle * (Math.PI / 180)) * this.speed;
      this.position.y += Math.sin(this.angle * (Math.PI / 180)) * this.speed;
    }

    ///////////////////////////////////////////////////////////////

    

    /////////////////////////////////////////////////////////////

    options = {

      position: { x: 325, y: 215 },
      moveToPos: { x: 325, y: 215 },
      wheelLineNum: 2,
      size: 5,
      speed: 1,
      frame: 0,
      cannonAngle: 67,

    }

    let tanks = [];

    for (let i = 0; i < 2; i += 1) {
      //debugger;
      let opts = JSON.parse(JSON.stringify(options));
      opts.position.y += i * 130;
      opts.moveToPos.y += i * 130;
      opts.team = i + 1;
      let tank = new Tank(ctx, opts);
      tanks.push(tank);
    }

    myTeam = 1;
    selectedTankIndex = -1;

    setInterval(function () {
      console.time('Game Loop')
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      game.misilles.forEach((m, index) => {
        m.render();
      });

      tanks.forEach((t, index) => {
        if (selectedTankIndex > -1 && selectedTankIndex !== index && t.checkCollision(tanks[selectedTankIndex])) {
          //tanks[selectedTankIndex].collide();
          tanks[selectedTankIndex].moveToPos = tanks[selectedTankIndex].position;
          //t.collide(tanks[selectedTankIndex]);
          tanks[selectedTankIndex].collide(t);
          //t.moveToPos  = JSON.parse(JSON.stringify(t.position));
          t.moveToPos = t.position;
        }

        t.moveTo();
      });



      
      


      console.timeEnd('Game Loop')
    }, 10);

    canvas.addEventListener('click', (event) => {
      const rect = canvas.getBoundingClientRect();
      const position = { x: event.clientX - rect.left, y: event.clientY - rect.top }
      let isClicked = false;

      tanks.forEach((t, index) => {
        t.selected = false;
        if (t.checkIfClicked(position)) {
          selectedTankIndex = index;
          isClicked = true;
        }
      });

      // Move the selected tank to the clicked point
      if (!isClicked) {
        tanks[selectedTankIndex].moveToPos = position;
       // tanks[selectedTankIndex].fireMisille(ctx);
      }
      tanks[selectedTankIndex].selected = true;


    });

    document.getElementById('shoot').onclick = function(){
      //alert('yo')
      tanks[0].fireMisille(ctx);
    }



  </script>
</body>

</html>